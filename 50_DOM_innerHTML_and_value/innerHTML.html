<!--
We learned in the previous chapter that the textContent property returns the text written inside a tag (for example, a div, h1, p, or other elements).

Sometimes textContent is not enough and you may find yourself needing to use innerHTML.

we use the querySelector and not the querySelectorAll.
-->
<div id="test">This is a sample text</div>

<script>
    const txt = document.querySelector("#test");
    console.log(txt.innerHTML);

    /*
    So far, there's no difference between textContent and innerHTML that's because this element does not contain any HTML elements.
     */
</script>
<div id="test2">This is a <strong>sample text 2</strong></div>
<script>
    const t1 = document.querySelector("#test2");
    console.log(`T1_before update: ${t1.textContent}`);
    console.log(`T2: ${t1.innerHTML}`);

    /*

    This is where you can see the difference between them:
textContent will return the text, with all the HTML tags stripped out.
innerHTML will return the HTML string inside of the element (it will not strip out HTML tags).
So, when you need to keep the HTML tags, you should use innerHTML. Otherwise textContent is the way to go.
     */
    //changing a text content inside an HTML tag.
    t1.textContent = "All Good Now!!!"
    console.log(`T1_after update: ${t1.textContent}`);

    //changing the HTML text....innerhtml will apply tags
    txt.innerHTML = "All <b>Good</b> Now!!"
    //note
    //if the string you're rendering is coming from your users, you should then stick to element.textContent = string and never change the innerHTML property to avoid ending up with unwanted HTML on your page.

    //emptying elements
</script>
<div id="banner">
    <h1>Hello World</h1>
    <p>lorem ipsum</p>
</div>
<script>
    const banner = document.querySelector("#banner");
    banner.innerHTML = ""; //or
    banner.textContent = "";
</script>